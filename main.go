package main

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/you/pawtrack/internal/handler"
	"github.com/you/pawtrack/internal/models"
	"github.com/you/pawtrack/internal/repository"
	"github.com/you/pawtrack/internal/service"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"

	// migrate
	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/database/sqlite"
	_ "github.com/golang-migrate/migrate/v4/source/file"

	// swagger
	_ "github.com/you/pawtrack/docs" // docs is generated by Swag CLI
)

// @title           Pawtrack API
// @version         1.0
// @description     API for tracking pet events.
// @host            localhost:8080
// @BasePath        /api/v1
func main() {
	// ENV with defaults
	addr := getenv("ADDR", ":8080")

	// DB (sqlite/postgres)
	db, err := openDB()
	if err != nil {
		log.Fatalf("open db: %v", err)
	}

	// Run migrations (golang-migrate), if enabled
	if getenv("RUN_MIGRATIONS", "false") == "true" {
		if err := runMigrations(); err != nil {
			log.Fatalf("migrations failed: %v", err)
		}
	}

	// Auto-seed (dev)
	if getenv("SEED_ON_START", "false") == "true" {
		if err := seedIfEmpty(db); err != nil {
			log.Printf("seed failed: %v", err)
		}
	}

	// Initialize layers
	// Repositories
	eventRepo := repository.NewEventRepository(db)
	dogRepo := repository.NewDogRepository(db)
	userRepo := repository.NewUserRepository(db)
	consultantRepo := repository.NewConsultantRepository(db)
	consultantNoteRepo := repository.NewConsultantNoteRepository(db)
	eventCommentRepo := repository.NewEventCommentRepository(db)

	// Services
	authService := service.NewAuthService(userRepo)
	eventService := service.NewEventService(eventRepo)
	dogService := service.NewDogService(dogRepo)
	userService := service.NewUserService(userRepo)
	consultantService := service.NewConsultantService(consultantRepo, dogRepo)
	consultantNoteService := service.NewConsultantNoteService(consultantNoteRepo, dogRepo)
	eventCommentService := service.NewEventCommentService(eventCommentRepo, eventRepo, dogRepo)

	// Handlers
	authHandler := handler.NewAuthHandler(authService)
	eventHandler := handler.NewEventHandler(eventService)
	dogHandler := handler.NewDogHandler(dogService)
	userHandler := handler.NewUserHandler(userService)
	healthHandler := handler.NewHealthHandler(db)
	consultantHandler := handler.NewConsultantHandler(consultantService)
	consultantNoteHandler := handler.NewConsultantNoteHandler(consultantNoteService)
	eventCommentHandler := handler.NewEventCommentHandler(eventCommentService)

	// Router
	r := handler.SetupRouter(eventHandler, dogHandler, userHandler, authHandler, healthHandler, consultantHandler, consultantNoteHandler, eventCommentHandler, authService)

	srv := &http.Server{Addr: addr, Handler: r}

	// Graceful shutdown
	go func() {
		if err := srv.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
			log.Fatalf("listen: %v", err)
		}
	}()
	log.Printf("pawtrack listening on %s", addr)

	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Printf("server shutdown: %v", err)
	}
	log.Printf("bye")
}

func getenv(key, def string) string {
	if v := os.Getenv(key); v != "" {
		return v
	}
	return def
}

// runMigrations applies migrations from MIGRATIONS_DIR (default ./migrations)
func runMigrations() error {
	dir := getenv("MIGRATIONS_DIR", "./migrations")
	sourceURL := fmt.Sprintf("file://%s", dir)
	dbType := getenv("DB_TYPE", "sqlite")

	var dbURL string
	if dbType == "postgres" {
		dbURL = getenv("DATABASE_URL", "")
		if dbURL == "" {
			host := getenv("PGHOST", "localhost")
			port := getenv("PGPORT", "5432")
			user := getenv("PGUSER", "pawtrack")
			pass := getenv("PGPASSWORD", "pawtrack")
			dbname := getenv("PGDATABASE", "pawtrack")
			dbURL = "postgres://" + user + ":" + pass + "@" + host + ":" + port + "/" + dbname + "?sslmode=disable"
		}
	} else {
		// sqlite
		dsn := getenv("SQLITE_DSN", "file:pawtrack.db?_busy_timeout=5000&_fk=1")
		// migrate expects sqlite:// or sqlite3:// scheme
		dbURL = "sqlite3://" + dsn
	}

	m, err := migrate.New(sourceURL, dbURL)
	if err != nil {
		return err
	}
	defer m.Close()
	if err := m.Up(); err != nil && !errors.Is(err, migrate.ErrNoChange) {
		return err
	}
	return nil
}

// seedIfEmpty adds some records if the table is empty
func seedIfEmpty(db *gorm.DB) error {
	var cnt int64
	if err := db.Model(&models.Event{}).Count(&cnt).Error; err != nil {
		return err
	}
	if cnt > 0 {
		return nil
	}
	now := time.Now().UTC()
	data := []models.Event{
		{Type: "walk", Note: "morning walk", At: now.Add(-6 * time.Hour)},
		{Type: "feed", Note: "feeding 150g", At: now.Add(-5 * time.Hour)},
		{Type: "meds", Note: "pill at 20:00", At: now.Add(-15 * time.Hour)},
	}
	return db.Create(&data).Error
}

func openDB() (*gorm.DB, error) {
	dbType := getenv("DB_TYPE", "sqlite")
	if dbType == "postgres" {
		url := os.Getenv("DATABASE_URL")
		if url == "" {
			// fallback: build DSN from environment variables
			host := getenv("PGHOST", "localhost")
			port := getenv("PGPORT", "5432")
			user := getenv("PGUSER", "pawtrack")
			pass := getenv("PGPASSWORD", "pawtrack")
			dbname := getenv("PGDATABASE", "pawtrack")
			url = "postgres://" + user + ":" + pass + "@" + host + ":" + port + "/" + dbname + "?sslmode=disable"
		}
		return gorm.Open(postgres.Open(url), &gorm.Config{})
	}
	// default sqlite
	dsn := getenv("SQLITE_DSN", "file:pawtrack.db?_busy_timeout=5000&_fk=1")
	return gorm.Open(sqlite.Open(dsn), &gorm.Config{})
}
